Maximum Product Subarray - Recursive Approach Answers

1. Answer: b) Because negative numbers can turn minimum products into maximum products

Explanation: When we multiply two negative numbers, the result becomes positive. This means that a minimum (most negative) product can become the maximum product when multiplied by a negative number. For example, if we have minimum product -6 and multiply by -2, we get 12 which could be the maximum. That's why we must track both maximum and minimum products at each step.

2. Answer: c) When start equals end (single element subarray)

Explanation: The base case occurs when we're looking at a subarray with just one element (start == end). In this case, both the maximum and minimum products are simply the value of that single element. This base case provides the foundation for building larger subarrays by combining results from smaller ones.

3. Answer: b) The start and end indices of a subarray

Explanation: In the memoization cache, the key is typically a string representation of the start and end indices (e.g., "start,end"). This allows us to store and retrieve the {max, min} product results for any specific subarray. When we encounter the same subarray again, we can return the cached result instead of recomputing it.

4. Answer: a) Negative numbers can make minimum products become maximum when multiplied

Explanation: This is the key insight that differentiates Maximum Product from Maximum Sum. In the sum version, we only need to track the maximum sum ending at each position. But with products, negative numbers can flip the sign, so the minimum product (most negative) can become the maximum when multiplied by another negative number. This requires tracking both max and min values.

5. Answer: b) Current element, current * prev_max, current * prev_min

Explanation: At each position i, we consider three possibilities for both maximum and minimum products ending at that position: (1) start a new subarray with just nums[i], (2) extend the previous maximum product by multiplying it with nums[i], or (3) extend the previous minimum product by multiplying it with nums[i]. We then take the max and min of these three options.

6. Answer: c) O(n^2)

Explanation: In the naive recursive approach that tries all subarrays, we have O(n^2) subproblems (all possible start,end pairs), and each subproblem is computed once due to memoization. The Kadane-style recursive approach is more efficient at O(n) since it only has n subproblems (one for each ending position), but the general recursive approach for all subarrays is O(n^2).

7. Answer: c) Zero naturally resets the product and is handled in the normal flow

Explanation: Zero is handled naturally in the algorithm without special cases. When we multiply any product by zero, the result is zero. This means zero effectively "resets" the running product, and we would consider starting a new subarray from the next element. The algorithm doesn't need special zero-handling logic because zero is just another number that gets processed through the normal multiplication and comparison operations.