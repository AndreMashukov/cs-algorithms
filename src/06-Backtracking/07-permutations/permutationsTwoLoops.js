// Given an array nums of distinct integers,
// return all the possible permutations.
// You can return the answer in any order.

const permutationsTwoLoops = (nums) => {
  const res = [] // Initialize the result array

  const dfs = (i) => {
    if (i === nums.length) {
      return [[]] // Base case: return an array with an empty array
    }

    const result = [] // Initialize the result array for this level of recursion
    const perms = dfs(i + 1) // Recursively get permutations of the remaining elements
    for (const perm of perms) {
      for (let j = 0; j <= perm.length; j++) {
        const newPerm = [...perm] // Create a copy of the current permutation
        // Insert the current number at index j
        newPerm.splice(j, 0, nums[i])
        result.push(newPerm) // Push the new permutation into the result array
      }
    }

    return result // Return the result array
  }

  res.push(...dfs(0)) // Collect all permutations from the dfs call
  return res // Return the final result array
}

// Example usage:
console.log(permutationsTwoLoops([1, 2, 3])) // Expected output: [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]

// Inserts the current number at every possible position
// in each permutation generated by the recursive call.
