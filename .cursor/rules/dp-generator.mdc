---
description: 
globs: 
alwaysApply: false
---
# Dynamic Programming Problem Structure Generator

You are an AI assistant specialized in creating structured solutions for dynamic programming problems from LeetCode. When given LeetCode URLs for dynamic programming problems, follow this exact structure:

## Directory Structure
For each problem, create a directory in `src/09-DP3/` with naming pattern: `{number}-{problemName}/`
- Use sequential numbering (04-, 05-, etc.)
- Use camelCase for problem names (e.g., `maximumSubarray`, `jumpGame`, `minimumPathSum`)

## Required Files per Problem
Create exactly 8 files for each problem:

### 1. recursive.js
**Structure:**
```javascript
// {Problem Number}. {Problem Title}
// {LeetCode URL}
// Problem Description:
// {Complete problem description from LeetCode}
//
// Example 1:
// {Example from LeetCode}
//
// Example 2:
// {Additional examples if available}
//
// Constraints:
// {Constraints from LeetCode}

/**
 * @param {type[]} paramName
 * @return {returnType}
 */
function {functionName}Dfs(params) {
  // Add comprehensive line-by-line comments explaining:
  // - What each variable represents
  // - The purpose of each operation
  // - Base cases and why they work
  // - Recursive logic and memoization strategy
  
  // Include memoization using Map() or appropriate data structure
  const memo = new Map();
  
  // Follow DFS/recursive approach with proper memoization
  const dfs = (param) => {
    if (memo.has(param)) {
      return memo.get(param);
    }
    
    // Base case
    if (/* base condition */) {
      return /* base value */;
    }
    
    // Recursive case
    const result = /* recursive calculation */;
    memo.set(param, result);
    return result;
  };
  
  return dfs(params);
}

// Example Usage:
// Include 3-4 test cases with expected outputs
```

### 2. dp.js
**Structure:**
```javascript
// Problem: {Problem Title}
// LeetCode URL: {URL}
// Problem Description:
// {Same description as recursive.js}

/**
 * @param {type[]} paramName
 * @return {returnType}
 */
function {functionName}Dp(params) {
  // Add comprehensive line-by-line comments explaining:
  // - DP array/table initialization and meaning
  // - Transition formula and logic
  // - How each state relates to previous states
  // - Final result extraction
  
  // Initialize DP array/table with appropriate dimensions
  const dp = Array(/* size */).fill(null).map(() => Array(/* size */).fill(/* initial value */));
  
  // Base cases
  dp[0][0] = /* initial value */;
  
  // Fill the DP table using nested loops
  for (let i = /* start */; i < /* end */; i++) {
    for (let j = /* start */; j < /* end */; j++) {
      // Calculate dp[i][j] based on previous states
      dp[i][j] = /* transition formula */;
    }
  }
  
  // Return final result
  return dp[/* final index */][/* final index */];
}

// Example Usage:
// Include same test cases as recursive.js
```

### 3. recursive-questions.md
Create exactly 10 multiple-choice questions focusing on:
- Algorithm flow and execution order (2 questions)
- Intermediate calculations and states (2 questions)
- Parameter meanings and transformations (2 questions)
- Base cases and recursive logic (2 questions)
- Most challenging/confusing parts of the algorithm (2 questions)
- Example-based questions (4 questions) - Generate these AFTER creating the recursive-example.md
- If there are multiple solutions in recursive.js file 
  then create Q&A only for the most optimized part

**Format:**
```markdown
# Problem: {Problem Title} (DFS with Memoization)

## Q1: {Question about algorithm structure/flow}
1. {Option 1}
2. {Option 2}
3. {Option 3}
4. {Option 4}

## Q2: {Question about base case or key logic}
1. {Option 1}
2. {Option 2}
3. {Option 3}
4. {Option 4}

[Continue for Q3-Q10...]
```

**Question Guidelines:**
- Focus on algorithm understanding, NOT time/space complexity
- Avoid generic options like "It's a bug", "It's a convention", "To prevent stack overflow", "To maintain consistency with mathematical conventions", " The algorithm has a bug", "Because the algorithm has an error", etc...
- Avoid questions related to memoization or alogrithm's performance, because the answers are very easy
- Ask about what gets calculated first/next, intermediate results, parameter meanings
- Target the most difficult/confusing aspects of the solution
- For example-based questions (Q7-Q10): Use the walkthrough from recursive-example.md to create questions about specific steps, calculations, or states shown in the example

### 4. recursive-answers.md
**Format:**
```markdown
# Problem: {Problem Title} (DFS with Memoization)

## Q1: {Question text from recursive-questions.md}
**Answer: {Answer number}**
{Brief Explanation}

## Q2: {Question text from recursive-questions.md}
**Answer: {Answer number}**
{Brief Explanation}

## Q3: {Question text from recursive-questions.md}
**Answer: {Answer number}**
{Brief Explanation}

## Q4: {Question text from recursive-questions.md}
**Answer: {Answer number}**
{Brief Explanation}

## Q5: {Question text from recursive-questions.md}
**Answer: {Answer number}**
{Brief Explanation}

## Q6: {Question text from recursive-questions.md}
**Answer: {Answer number}**
{Brief Explanation}

## Q7: {Question text from recursive-questions.md}
**Answer: {Answer number}**
{Brief Explanation}

## Q8: {Question text from recursive-questions.md}
**Answer: {Answer number}**
{Brief Explanation}

## Q9: {Question text from recursive-questions.md}
**Answer: {Answer number}**
{Brief Explanation}

## Q10: {Question text from recursive-questions.md}
**Answer: {Answer number}**
{Brief Explanation}
```

**Answer Guidelines:**
- Always include the full question text from recursive-questions.md before each answer
- Vary answer numbers (don't use same number repeatedly)
- Make sure answers correspond to correct options from questions

### 5. dp-questions.md
Same format as recursive-questions.md but focused on:
- DP table/array initialization and updates (2 questions)
- State transitions and dependencies (2 questions)
- Order of computation in DP approach (2 questions)
- Relationship between current and previous states (2 questions)
- Most challenging/confusing parts of the DP algorithm (2 questions)
- Example-based questions (4 questions) - Generate these AFTER creating the dp-example.md
- If there are multiple solutions in dp.js file 
  then create Q&A only for the most optimized part

### 6. dp-answers.md
Same format as recursive-answers.md for DP questions (10 answers total).

**Format:**
```markdown
# Problem: {Problem Title} (DP Approach)

## Q1: {Question text from dp-questions.md}
**Answer: {Answer number}**
{Brief Explanation}

## Q2: {Question text from dp-questions.md}
**Answer: {Answer number}**
{Brief Explanation}

[Continue for Q3-Q10 with full questions from dp-questions.md]
```

**Answer Guidelines:**
- Always include the full question text from dp-questions.md before each answer
- Vary answer numbers (don't use same number repeatedly)
- Make sure answers correspond to correct options from questions

### 7. recursive-example.md
Create a simple, step-by-step walkthrough of how the recursive algorithm works:
- Use the simplest possible input example
- Show the execution flow step by step
- Explain what gets calculated at each recursive call
- Include memoization updates if applicable
- Keep explanations clear and beginner-friendly
- Include a detailed text diagram visualizing the trickiest part of the algorithm:
  - Show the recursion tree or call stack for a key example
  - Visualize parameter values and return values at each step
  - Use ASCII art with arrows to show the flow of execution
  - Highlight the most challenging concept with annotations
  - Explain why this particular aspect is difficult to understand

### 8. dp-example.md
Create a simple, step-by-step walkthrough of how the DP algorithm works:
- Use the same simple input as recursive example
- Start by clearly explaining the structure of the DP array/table:
  - What each dimension represents
  - What the values in each cell mean
  - How the indices correspond to the problem state
- Show how the DP table/array gets filled step by step
- Explain the state transitions and why each value is calculated
- Visualize the DP array updates at each step with clear formatting
- Include diagrams of the array state at key steps with proper alignment
- Keep explanations clear and beginner-friendly
- Include a detailed text diagram visualizing the trickiest part of the algorithm:
  - Show the state of the DP table at a critical calculation step
  - Use ASCII art (with +--+, |, /, etc.) to create visual representations
  - Add arrows to show dependencies between states
  - Include a concrete calculation example with the actual numbers
  - Explain why this particular aspect is tricky with numbered points

## Implementation Guidelines

### Code Quality Requirements:
- **Comprehensive Comments**: Every significant line must have a comment explaining its purpose
- **Variable Naming**: Use descriptive names that clearly indicate purpose
- **Function Naming**: Use pattern `{problemName}Dfs` and `{problemName}Dp`
- **Examples**: Include 3-4 test cases with expected outputs
- **Indentation**: Use exactly 2 spaces for indentation in all code files
- **Line Endings**: Use Unix-style line endings (LF)
- **Semicolons**: Always use semicolons at the end of statements
- **Quotes**: Use double quotes for strings

### Problem Research:
1. Visit each LeetCode URL to get complete problem details
2. Extract: title, description, examples, constraints, function signature
3. Understand both recursive and DP approaches for the problem
4. Create comprehensive solutions with educational focus

### Q&A Creation Strategy:
- Questions should test deep understanding of algorithm mechanics
- Focus on "what happens when..." and "what does this represent..." type questions
- Avoid surface-level questions about complexity or general programming concepts
- Target the most intellectually challenging aspects of each solution
- **Generate example-based questions ONLY after completing the respective example files**
- Example-based questions should reference specific steps, calculations, or states from the walkthrough examples

## Example Directory Structure:
```
src/09-DP3/
├── 04-maximumSubarray/
│   ├── recursive.js
│   ├── dp.js
│   ├── recursive-questions.md
│   ├── recursive-answers.md
│   ├── dp-questions.md
│   ├── dp-answers.md
│   ├── recursive-example.md
│   └── dp-example.md
├── 05-jumpGame/
│   └── [same 8 files]
└── ...
```

When given LeetCode URLs, process them sequentially with proper delays and create the complete directory structure for each problem following this exact template.

## Additional Rules: Answers and Markdown Format

- Each answer MUST include the full corresponding question text directly above the answer and explanation.
- Questions should be copied exactly as they appear in the question files.
- All options (1-4) should be included with the question text.
- All generated files for questions and answers must use valid Markdown format with appropriate headings, lists, and code blocks as needed.