---
description: Rules for creating comprehensive ASCII diagrams and visual explanations for algorithm solutions
globs: ["**/*.md", "**/*.txt", "**/*.js"]
alwaysApply: false
---

# Algorithm Diagram Creation Rules

## Core Principles

1. **Always supplement code with visual explanations** when solving algorithm problems
2. **Use step-by-step walkthroughs** with concrete examples
3. **Show state transitions** and data structure changes
4. **Include both high-level flow and detailed execution traces**

## File Organization

**MANDATORY: Create diagrams in separate markdown files**

- **Naming convention:** Use the format `algorithmName.diagram.md` for consistency and discoverability
- **Location:** Place diagram files in the same directory as the main solution file
- **Purpose:** Keep diagrams separate from code to maintain clean code files and allow for extensive visual documentation
- **Cross-referencing:** Reference diagram files from code comments when helpful

**Benefits:**
- Keeps source code clean and focused
- Allows for extensive diagram documentation without cluttering code
- Makes diagrams easily discoverable and referenceable
- Enables collaborative diagram editing without touching implementation code

## Diagram Types and Patterns

### 1. Step-by-Step Algorithm Walkthrough

**Use for:** Array operations, string processing, iterative algorithms

**Format:**
```
=== Step N ===
State: [description of current state]
Variables: var1=value, var2=value
Action: [what happens in this step]
Result: [new state after action]
```

**Example structure:**
- Show initial state
- Number each step clearly
- Display variable values at each step
- Use arrows (→, ↓, ↑) to show movement/direction
- Mark important transitions with ✅/❌

### 2. Table/Matrix Building Visualization

**Use for:** Dynamic programming, 2D array problems

**Format:**
```
      j=0  j=1  j=2  j=3
    +-------------------+
i=0 | T  |  F |  T |  F |
    |    | ↗  | ↗  | ↗  |
i=1 |    | T  |  F | T  |
    |    |    | ↗  | ↗  |
i=2 |    |    | T  |  F |
    +-------------------+
```

**Guidelines:**
- Show dependency arrows (↗, ↑, ←) between cells
- Use different lengths for different iterations
- Mark computed vs. base cases
- Include row/column headers with meaningful labels
- Show the filling order with numbered steps

### 3. Recursion Trees and Call Stacks

**Use for:** Recursive algorithms, backtracking, tree traversal

**Tree Format:**
```
                dfs(0)
            /"substring"\
           /              \
      "word1" ✓          "word2" ✓
         /                    \
     dfs(5)                dfs(6)
    /"rest"\              /"rest2"\
   /        \             /        \
```

**Call Stack Format:**
```
Step 1:          Step 2:          Step 3:
+-----------+    +-----------+    +-----------+
| dfs(0)    |    | dfs(0)    |    | dfs(0)    |
+-----------+    +-----------+    +-----------+
                 | dfs(3)    |    | dfs(3)    |
                 +-----------+    +-----------+
                                 | dfs(7)    |
                                 +-----------+
```

**Guidelines:**
- Show both tree structure and linear call stack
- Mark base cases clearly
- Include parameter values in function calls
- Use ✓/❌ to show valid/invalid paths
- Show return values flowing back up

### 4. Flow Diagrams for Processes

**Use for:** Encoding/decoding, parsing, state machines

**Format:**
```
Input: [initial_data]
  |
  | Process Step 1
  v
Intermediate: [transformed_data]
  |
  | Process Step 2  
  v
Output: [final_result]
```

**Guidelines:**
- Use boxes for states/data
- Use arrows with labels for transitions
- Show concrete examples alongside general form
- Include edge cases and special conditions

### 5. Index and Pointer Visualization

**Use for:** Two pointers, sliding window, array manipulation

**Format:**
```
Array:    [a, b, c, d, e, f]
Indexes:   0  1  2  3  4  5
           ^     ^
           i     j
```

**Guidelines:**
- Always show both data and indices
- Use ^ or ↑ to mark pointer positions
- Show pointer movement across iterations
- Include range markers for subarrays [i...j]

### 6. Constraint Propagation

**Use for:** Digit DP, constrained search, backtracking with pruning

**Format:**
```
Position 0 (tight=true):
├─ digit=0 → tight=false (freedom for rest)
├─ digit=1 → tight=false (freedom for rest)  
└─ digit=2 → tight=true  (constrained)
             │
             Position 1 (tight=true):
             ├─ digit=0,1,2,3 only
             └─ digit>3 invalid ❌
```

## Anti-Patterns to Avoid

- ❌ **Incomplete diagrams** that cut off mid-flow (CRITICAL: always show start to finish)
- ❌ **Mixed box styles** (never mix double-line, single-line, or ASCII boxes in one diagram)
- ❌ Diagrams without concrete examples
- ❌ Missing intermediate steps in complex algorithms  
- ❌ Inconsistent notation or symbols
- ❌ Diagrams that don't match the actual code implementation
- ❌ Over-complicated visuals that obscure rather than clarify
- ❌ Missing explanations of why each step works
- ❌ Poor alignment and spacing that makes diagrams hard to read

## When to Create Diagrams

**Always create diagrams for:**
- Recursive algorithms (show call tree + execution trace)
- Dynamic programming (show table building process)
- Graph algorithms (show traversal and state changes)
- Complex data structure operations
- Algorithms with non-obvious state transitions

**Consider diagrams for:**
- Optimization problems with multiple approaches
- Algorithms with intricate loop logic
- Problems involving coordinate systems or 2D grids
- Parsing and string manipulation algorithms

Remember: The goal is to make complex algorithms accessible and understandable. A good diagram should enable someone to implement the algorithm just from the visual explanation.

## Formatting Standards

### Typography
- Use `monospace` for code elements and variable names
- Use **bold** for important concepts
- Use *italics* for explanations and notes
- Use → ↑ ↓ ← for directional flow
- Use ✅ ❌ for valid/invalid states
- Use ╔═╗ ║ ╚═╝ for emphasis boxes when needed

### Structure
- Always start with problem statement and example
- Include both algorithmic overview and detailed trace
- End with key insights and complexity analysis
- Use horizontal rules (===) to separate major sections
- Number steps consistently (1, 2, 3... or Step A, Step B...)

### Code Integration
- Reference specific line numbers when explaining code
- Show variable states alongside code execution
- Include memoization cache states for DP problems
- Highlight the relationship between code and diagram

### Consistency Requirements for Flow Diagrams

**CRITICAL: Diagrams must be COMPLETE and CONSISTENT**

#### 1. Completeness - Never Cut Off Mid-Flow
- ❌ **NEVER create incomplete diagrams** that stop mid-process
- ✅ **ALWAYS complete** the entire algorithm flow from start to finish
- ✅ Show the full path: Start → All Steps → End
- ✅ If showing a process, include ALL steps, not just the beginning
- ✅ If simplifying, clearly mark it as "simplified" and show the complete flow

#### 2. Consistent Box Formatting
Choose ONE style and use it consistently throughout the entire diagram:

**Option A: Double-line boxes (for emphasis)**
```
╔═══════════════════╗
║   Box Content     ║
╚═══════════════════╝
```
- Use `═` for horizontal lines
- Use `║` for vertical lines  
- Use `╔` `╗` `╚` `╝` for corners

**Option B: Single-line boxes (simple and clean)**
```
┌───────────────────┐
│   Box Content     │
└───────────────────┘
```
- Use `─` for horizontal lines
- Use `│` for vertical lines
- Use `┌` `┐` `└` `┘` for corners

**Option C: ASCII-only boxes (most compatible)**
```
+-------------------+
|   Box Content     |
+-------------------+
```
- Use `-` for horizontal lines
- Use `|` for vertical lines
- Use `+` for corners

**CRITICAL RULE:** Never mix different box styles in the same diagram!

#### 3. Complete Flow Structure
Every flow diagram must have:
- **Clear start point** (title/header box or labeled entry)
- **Complete flow path** (all intermediate steps shown)
- **Clear end point** (final result box or continuation indicator)
- **Consistent arrow direction** (use → ↓ ↑ ← consistently)

#### 4. Proper Alignment and Spacing
- Maintain consistent indentation throughout
- Align boxes vertically and horizontally
- Use consistent spacing between elements (2-4 spaces)
- Ensure arrows align properly with boxes
- Use proper line breaks for readability

#### 5. Example: Good vs Bad

**❌ BAD (Incomplete, inconsistent):**
```
╔════════════════════════════════════╗
║  Reconstruction Algorithm Overview ║
╚═══════════════╦════════════════════╝
                ↓
        ┌───────────────────────┐
        │  Get Root from Preorder  │
        └───────────────┬───────┘
                ↓
```

**Problems:**
- Diagram cuts off mid-flow (no completion)
- Mixed box styles (double-line header, single-line boxes)
- No end point shown
- Incomplete algorithm representation

**✅ GOOD (Complete, consistent single-line style):**
```
┌────────────────────────────────────┐
│ Reconstruction Algorithm Overview  │
└───────────────┬────────────────────┘
                ↓
        ┌────────────────────────┐
        │ Get Root from Preorder │
        └───────────────┬────────┘
                        ↓
        ┌───────────────────────┐
        │ Find Root in Inorder  │
        └───────────────┬───────┘
                        ↓
        ┌────────────────────────┐
        │ Split Arrays & Recurse │
        └───────────────┬────────┘
                        ↓
        ┌───────────────────────┐
        │   Return Root Node    │
        └───────────────────────┘
```

**Why it's good:**
- Complete flow from start to finish
- Consistent box style (single-line throughout, including header)
- All steps shown
- Clear start and end points
- Proper alignment: arrows centered, boxes aligned vertically
- Consistent spacing and indentation

**✅ ALTERNATIVE GOOD (Consistent double-line style):**
```
╔════════════════════════════════════╗
║  Reconstruction Algorithm Overview ║
╚═══════════════╦════════════════════╝
                ↓
        ╔════════════════════════╗
        ║ Get Root from Preorder ║
        ╚═══════════════╦════════╝
                        ↓
        ╔═══════════════════════╗
        ║ Find Root in Inorder  ║
        ╚═══════════════╦═══════╝
                        ↓
        ╔════════════════════════╗
        ║ Split Arrays & Recurse ║
        ╚═══════════════╦════════╝
                        ↓
        ╔═══════════════════════╗
        ║   Return Root Node    ║
        ╚═══════════════════════╝
```

#### 6. Quick Consistency Checklist
Before finalizing any flow diagram, verify:
- [ ] Diagram is complete (has clear start AND end)
- [ ] Uses consistent box characters throughout (no mixing styles)
- [ ] All steps in the process are shown
- [ ] Properly aligned vertically and horizontally
- [ ] Consistent spacing between elements
- [ ] Arrows align properly with boxes
- [ ] Readable and clear in plain text format
- [ ] If simplified, clearly marked as such

## Required Sections for Complex Algorithms

1. **Problem Setup:** Input, output, constraints
2. **Algorithm Overview:** High-level approach diagram
3. **Detailed Walkthrough:** Step-by-step with concrete example
4. **State Visualization:** Data structure changes over time
5. **Edge Cases:** Special conditions and boundary handling
6. **Key Insights:** What makes the algorithm work
7. **Complexity Analysis:** Time/space with justification

## Examples of Good Diagram Comments

```javascript
// Visual representation of the encoding process:
// Input: ["hello", "world"]
// Step 1: "hello" → "5#hello"  
// Step 2: "world" → "5#world"
// Result: "5#hello5#world"
```

```javascript
// Recursion tree for dfs(startIndex):
//       dfs(0)
//      /      \
//   "cat"    "cats"  
//    |         |
//  dfs(3)    dfs(4)
//    |         |
//  "sand"    "and"
```

description:
globs:
alwaysApply: false
---
